{"version":3,"sources":["../../../src/php/json/json_decode.js"],"names":["module","exports","json_decode","strJson","$global","window","global","$locutus","php","json","JSON","parse","err","SyntaxError","Error","last_error_json","chars","join","cx","RegExp","j","text","lastIndex","test","replace","a","charCodeAt","toString","slice","m","eval"],"mappings":";;;;AAAAA,OAAOC,OAAP,GAAiB,SAASC,WAAT,CAAsBC,OAAtB,EAA+B;AAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AAQA,MAAMC,UAAW,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyCC,MAA1D;AACAF,UAAQG,QAAR,GAAmBH,QAAQG,QAAR,IAAoB,EAAvC;AACA,MAAMA,WAAWH,QAAQG,QAAzB;AACAA,WAASC,GAAT,GAAeD,SAASC,GAAT,IAAgB,EAA/B;;AAEA,MAAMC,OAAOL,QAAQM,IAArB;AACA,MAAI,QAAOD,IAAP,yCAAOA,IAAP,OAAgB,QAAhB,IAA4B,OAAOA,KAAKE,KAAZ,KAAsB,UAAtD,EAAkE;AAChE,QAAI;AACF,aAAOF,KAAKE,KAAL,CAAWR,OAAX,CAAP;AACD,KAFD,CAEE,OAAOS,GAAP,EAAY;AACZ,UAAI,EAAEA,eAAeC,WAAjB,CAAJ,EAAmC;AACjC,cAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED;AACAP,eAASC,GAAT,CAAaO,eAAb,GAA+B,CAA/B;AACA,aAAO,IAAP;AACD;AACF;;AAED,MAAMC,QAAQ,CACZ,IADY,EAEZ,MAFY,EAGZ,eAHY,EAIZ,QAJY,EAKZ,QALY,EAMZ,QANY,EAOZ,eAPY,EAQZ,eARY,EASZ,eATY,EAUZ,QAVY,EAWZ,eAXY,EAYZC,IAZY,CAYP,EAZO,CAAd;AAaA,MAAMC,KAAK,IAAIC,MAAJ,CAAW,MAAMH,KAAN,GAAc,GAAzB,EAA8B,GAA9B,CAAX;AACA,MAAII,UAAJ;AACA,MAAIC,OAAOlB,OAAX;;AAEA;AACA;AACA;AACAe,KAAGI,SAAH,GAAe,CAAf;AACA,MAAIJ,GAAGK,IAAH,CAAQF,IAAR,CAAJ,EAAmB;AACjBA,WAAOA,KAAKG,OAAL,CAAaN,EAAb,EAAiB,UAAUO,CAAV,EAAa;AACnC,aAAO,QAAQ,CAAC,SAASA,EAAEC,UAAF,CAAa,CAAb,EACtBC,QADsB,CACb,EADa,CAAV,EAEZC,KAFY,CAEN,CAAC,CAFK,CAAf;AAGD,KAJM,CAAP;AAKD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,IAAK,eAAD,CACPN,IADO,CACFF,KAAKG,OAAL,CAAa,oCAAb,EAAmD,GAAnD,EACHA,OADG,CACK,iEADL,EACwE,GADxE,EAEHA,OAFG,CAEK,sBAFL,EAE6B,EAF7B,CADE,CAAV;;AAKA,MAAIK,CAAJ,EAAO;AACL;AACA;AACA;AACA;AACAT,QAAIU,KAAK,MAAMT,IAAN,GAAa,GAAlB,CAAJ,CALK,CAKsB;AAC3B,WAAOD,CAAP;AACD;;AAED;AACAb,WAASC,GAAT,CAAaO,eAAb,GAA+B,CAA/B;AACA,SAAO,IAAP;AACD,CAlGD","file":"json_decode.js","sourcesContent":["module.exports = function json_decode (strJson) { // eslint-disable-line camelcase\n  //       discuss at: https://phpjs.org/functions/json_decode/\n  //      original by: Public Domain (https://www.json.org/json2.js)\n  // reimplemented by: Kevin van Zonneveld (https://kevin.vanzonneveld.net)\n  //      improved by: T.J. Leahy\n  //      improved by: Michael White\n  //           note 1: If node or the browser does not offer JSON.parse,\n  //           note 1: this function falls backslash\n  //           note 1: to its own implementation using eval, and hence should be considered unsafe\n  //        example 1: json_decode('[ 1 ]')\n  //        returns 1: [1]\n\n  /*\n    https://www.JSON.org/json2.js\n    2008-11-19\n    Public Domain.\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n    See https://www.JSON.org/js.html\n  */\n\n  const $global = (typeof window !== 'undefined' ? window : global)\n  $global.$locutus = $global.$locutus || {}\n  const $locutus = $global.$locutus\n  $locutus.php = $locutus.php || {}\n\n  const json = $global.JSON\n  if (typeof json === 'object' && typeof json.parse === 'function') {\n    try {\n      return json.parse(strJson)\n    } catch (err) {\n      if (!(err instanceof SyntaxError)) {\n        throw new Error('Unexpected error type in json_decode()')\n      }\n\n      // usable by json_last_error()\n      $locutus.php.last_error_json = 4\n      return null\n    }\n  }\n\n  const chars = [\n    '\\u0000',\n    '\\u00ad',\n    '\\u0600-\\u0604',\n    '\\u070f',\n    '\\u17b4',\n    '\\u17b5',\n    '\\u200c-\\u200f',\n    '\\u2028-\\u202f',\n    '\\u2060-\\u206f',\n    '\\ufeff',\n    '\\ufff0-\\uffff'\n  ].join('')\n  const cx = new RegExp('[' + chars + ']', 'g')\n  let j\n  let text = strJson\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n  cx.lastIndex = 0\n  if (cx.test(text)) {\n    text = text.replace(cx, function (a) {\n      return '\\\\u' + ('0000' + a.charCodeAt(0)\n        .toString(16))\n        .slice(-4)\n    })\n  }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n  const m = (/^[\\],:{}\\s]*$/)\n    .test(text.replace(/\\\\(?:[\"\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n      .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?/g, ']')\n      .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))\n\n  if (m) {\n    // In the third stage we use the eval function to compile the text into a\n    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n    // in JavaScript: it can begin a block or an object literal. We wrap the text\n    // in parens to eliminate the ambiguity.\n    j = eval('(' + text + ')') // eslint-disable-line no-eval\n    return j\n  }\n\n  // usable by json_last_error()\n  $locutus.php.last_error_json = 4\n  return null\n}\n"]}